\documentclass[a4paper,oneside,14pt]{extarticle}

\include{preamble}

\begin{document}

\include{title}
\setcounter{page}{2}
\renewcommand{\contentsname}{СОДЕРЖАНИЕ}
\tableofcontents

\newpage

\section{Функции обработчика прерывания от системного таймера}

\subsection{Windows}

\subsubsection*{По тику}
\begin{itemize}
	\item инкремент счетчика системного времени;
	\item декремент кванта;
	\item декремент счетчиков времени отложенных задач;
    \item если активен механизм профилирования ядра, то инициализация отложенного вызова обработчика ловушки профилирования ядра добавлением объекта в очередь DPC (обработчик ловушки профилирования регистрирует адрес команды, выполнявшейся на момент прерывания);
\end{itemize}

\subsubsection*{По главному тику}
\begin{itemize}
    \item освобождение объекта <<событие>>, которое ожидает диспетчер настройки баланса. Диспетчер настройки баланса по событию от таймера сканирует очередь готовых процессов и повышает приоритет процессов, которые находились в очереди в состоянии ожидания дольше 4 секунд.
\end{itemize}

\subsubsection*{По кванту}
\begin{itemize}
    \item инициализация диспетчеризации потоков добавлением соответствующего объекта в очередь DPC.
\end{itemize}

\subsection{UNIX}

\subsubsection*{По тику}
\begin{itemize}
	\item инкремент счетчика тиков аппаратного таймера;
	\item обновление системного времени (времени дня) и других связанных с ним таймеров;
	\item обновление статистики использования процессора текущим процессом (инкремент поля p\_cpu дескриптора текущего процесса до максимального значения, равного 127);
	\item декремент счетчика времени, оставшегося до отправления на выполнение отложенных вызовов, при достижении нулевого значения счетчика --- выставление флага, указывающего на необходимость запуска обработчика отложенного вызова;
    \item декремент кванта потока.
\end{itemize}

\subsubsection*{По главному тику} 
\begin{itemize}
	\item регистрация отложенных вызовов функций, относящихся к работе планировщика,
	таких как пересчет приоритетов;
	\item пробуждение (то есть регистрация отложенного вызова процедуры wakeup, которая перемещает дескриптор процесса из списка <<спящих>> в очередь <<готовых к выполнению>>) системных процессов swapper и pagedaemon;
	\item декремент счетчика времени, оставшегося до посылки одного из следующих сигналов:
	\begin{itemize}
		\item SIGALRM --- сигнал, посылаемый процессу по истечении времени, заданного функцией alarm() (будильник реального времени);
		\item SIGPROF --- сигнал, посылаемый процессу по истечении времени, заданного в таймере профилирования (будильник профиля процесса);
		\item SIGVTALRM --- сигнал, посылаемый процессу по истечении времени работы в режиме задачи (будильник виртуального времени).
	\end{itemize}
\end{itemize}

\subsubsection*{По кванту}
\begin{itemize}
	\item если текущий процесс превысил выделенный ему квант процессорного времени, отправка ему сигнала SIGXCPU.
\end{itemize}

\section{Пересчет динамических приоритетов}

В ОС семейств UNIX и Windows динамически пересчитываться могут только приоритеты пользовательских процессов.
% Динамические приоритеты могут быть только у пользовательских процессов. В операционных системах процесс является владельцем ресурсов, в том числе --- владельцем приоритета.

\subsection{Windows}
%475 Р
В Windows реализуется приоритетная, вытесняющая система планирования, при  которой всегда выполняется хотя бы один готовый поток с самым высоким приоритетом. 

После того как поток был выбран для запуска, он запускается на время, называемое квантом.
Но поток может и не израсходовать свой квант времени: если становится готов к запуску другой поток с более высоким приоритетом, текущий выполняемый поток может быть вытеснен.

Единого модуля под названием «планировщик» не существует.
Процедуры, выполняющие обязанности по диспетчеризации, обобщенно называются диспетчером ядра.
Диспетчеризации потоков могут потребовать следующие события:
\begin{itemize}
	\item поток становится готовым к выполнению;
	\item поток выходит из состояния выполнения из-за окончания его кванта времени;
	\item поток завершается или переходит в состояние ожидания;
	\item изменяется приоритет потока;
	\item изменяется родственность процессора потока.
\end{itemize}

Windows использует 32 уровня приоритета, от 0 до 31. Эти значения  разбиваются на части следующим образом:
\begin{itemize}
	\item шестнадцать уровней реального времени (от 16 до 31);
	\item шестнадцать изменяющихся уровней (от 0 до 15), из которых уровень 0 зарезервирован для потока обнуления страниц. 
\end{itemize}

Уровни приоритета потоков назначаются из двух разных позиций: от Windows API и от ядра Windows.

Windows API систематизирует процессы по классу приоритета, который присваивается им при их создании:
\begin{itemize}
	\item реального времени (real-time (4));
	\item высокий (high (3));
	\item выше обычного (above normal (7));
	\item обычный (normal (2));
	\item ниже обычного (below normal (5));
	\item простой (idle (1)).
\end{itemize}

Затем назначается относительный приоритет потоков в рамках процессов.
Здесь номера представляют изменение приоритета, применяющееся к базовому приоритету процесса:
\begin{itemize}
	\item критичный по времени (time-critical (15));
	\item наивысший (highest (2));
	\item выше обычного (above normal (1));
	\item обычный (normal (0));
	\item ниже обычного (below normal (-1));
	\item самый низший (lowest (-2));
	\item простоя (idle (-15)).
\end{itemize}

Уровень, критичный по времени, и уровень простоя (+15 и -15) называются уровнями насыщения и представляют конкретные применяемые уровни вместо смещений.
Относительный приоритет --- это приращение к базовому приоритету процесса.

Соответствие между приоритетами Windows API и ядра Windows приведено в таблице \ref{tbl:priority}.
\begin{table}[h]
    \caption{Соответствие между приоритетами Windows API и ядра Windows}
	\begin{center}
		\begin{tabular}{|l|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|p{45pt}|} 
			\hline
			{} & {real-time} & {high} & {above normal} & {normal} & {below normal} & {idle}\\
			\hline
			{time critical} & 31 & 15 & 15 & 15 & 15 & 15 \\
			\hline
			{highest} & 26 & 15 & 12 & 10 & 8 & 6 \\
			\hline
			{above normal} & 25 & 14 & 11 & 9 & 7 & 5 \\
			\hline
			{normal} & 24 & 13 & 10 & 8 & 6 & 4 \\
			\hline
			{below normal} & 23 & 12 & 9 & 7 & 5 & 3 \\
			\hline
			{lowest} & 22 & 11 & 8 & 6 & 4 & 2 \\
			\hline
			{idle} & 16 & 1 & 1 & 1 & 1 & 1 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:priority}
\end{table}

Приложения пользователя обычно запускаются с базовым приоритетом (normal), поэтому их исходный поток чаще всего выполняется с уровнем приоритета 8. 

У процесса имеется только одно базовое значение приоритета, а у каждого потока имеется два значения приоритета: текущее (динамическое) и базовое.
Решения по планированию принимаются исходя из текущего приоритета.
Система при определенных обстоятельствах на короткие периоды времени повышает приоритет потоков в динамическом диапазоне (от 1 до 15).
Windows никогда не регулирует приоритет потоков в диапазоне реального времени (от 16 до 31), поэтому они всегда имеют один и тот же базовый и текущий приоритет.

Исходный базовый приоритет потока наследуется от базового приоритета процесса.
Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал.

Планировщик Windows периодически настраивает текущий приоритет потоков, используя внутренний механизм повышения приоритета.
Во многих случаях это делается для уменьшения различных задержек и повышения восприимчивости системы, а также чтобы у потоков была возможность выполнения и освобождения ресурсов.  


Повышение приоритета вступает в действие немедленно и может  вызвать изменения в планировании процессора.
Однако если поток использует весь свой следующий квант, то он теряет один уровень приоритета.
Если же он использует второй полный квант, то он перемещается вниз еще  на один уровень, и так до тех пор, пока не дойдет до своего базового уровня. 

Сценарии повышения приоритета:
\begin{itemize}
	\item Повышение вследствие событий планировщика или диспетчера (сокращение задержек).
	\item Повышение вследствие завершения ввода-вывода (сокращение задержек --- поток может вновь запуститься и начать новую операцию ввода-вывода). В таблице \ref{tab:io} приведены рекомендуемые значения повышения приоритета для устройств ввода-вывода.
	\item Повышение вследствие ввода из пользовательского интерфейса (сокращение задержек и времени отклика).
	\item Повышение приоритета владельца блокировки.
	\item Повышение вследствие слишком продолжительного ожидания ресурса исполняющей системы (предотвращение зависания).
	\item Повышение в случае, когда готовый к запуску поток не был запущен в течение определенного времени (чтобы исключить бесконечное откладывание процессов).
	%табличку
	%\item Если поток ждал на семафоре, мьютексе или другом событии, то повышение при его освобождении.
	\item Повышение вследствие ожидания объекта ядра.
	\item Повышение приоритета потоков первого плана после ожидания (улучшение отзывчивости интерактивных приложений).
	\item Повышение приоритета после пробуждения GUI-потока (потоки-владельцы окон получают при пробуждении дополнительное повышение приоритета на 2).
	\item Повышения приоритета, связанные с перезагруженностью центрального процессора (CPU Starvation).
	\item Другие псевдоповышающие механизмы, проявляющие себя при проигрывании мультимедиа. В отличие от других повышений приоритета, эти механизмы применяются непосредственно в режиме ядра. Повышение приоритета проигрывания мультимедиа управляются службой планировщика класса мультимедиа MMCSS (это не является настоящим повышением, служба просто устанавливает по необходимости новые базовые приоритеты для потоков).
\end{itemize}
% \begin{itemize}
% \item Повышение вследствие событий планировщика или диспетчера (сокращение задержек).
% Здесь речь идёт о ситуациях, когда система может временно увеличить приоритет потоку для снижения времени отклика или для более быстрого обслуживания «важных» задач планировщика.

% \item Повышение вследствие завершения ввода-вывода (сокращение задержек — поток может вновь запуститься и начать новую операцию ввода-вывода).  
% При завершении определённых операций ввода-вывода Windows временно повышает приоритет потоков, ожидавших эти операции, чтобы они быстрее возобновили выполнение и обработали поступившие данные. В таблице \ref{tab:io} приведены рекомендуемые значения повышения приоритета для устройств ввода-вывода.

% %Драйвер устройства ввода-вывода, используя функцию \texttt{IoCompleteRequest}, указывает, что после завершения операции требуется динамическое повышение приоритета. После такого повышения приоритет постепенно понижается, пока не вернётся к базовому.

% \item Повышение вследствие ввода из пользовательского интерфейса (сокращение задержек и времени отклика).  
% Потоки, обрабатывающие пользовательский ввод (например, клики мыши, нажатия клавиш), получают дополнительное повышение приоритета, чтобы повысить интерактивность и отзывчивость приложения.

% \item Повышение приоритета владельца блокировки. Когда поток владеет важной системной блокировкой (например, мьютексом или критической секцией), есть механизмы, позволяющие временно повысить его приоритет, чтобы избежать долгого удержания ресурса и «пробок» в других потоках.

% \item Повышение вследствие слишком продолжительного ожидания ресурса исполняющей системы (предотвращение зависания).  
% Если поток слишком долго ожидает важный ресурс, система может немного увеличить его приоритет, чтобы ускорить получение ресурса и снять блокировку (тем самым избегая потенциального взаимного блокирования или «голодания»).

% \item Повышение в случае, когда готовый к запуску поток не был запущен в течение определённого времени (чтобы исключить бесконечное откладывание процессов).  
% Если поток находится в очереди готовых к выполнению, но не получает процессор достаточно долго, система повышает его приоритет и даёт ему шанс на выполнение.

% \item Повышение вследствие ожидания объекта ядра.  
% По окончании ожидания на событии, семафоре или другом объекте ядра (через вызовы \texttt{SetEvent}, \texttt{PulseEvent}, \texttt{ReleaseSemaphore} и т. д.) приоритет потока может временно подняться на 1. Аналогичные механизмы действуют при вызове функций \texttt{NtSetEventBoostPriority} и \texttt{KeSetEventBoostPriority} — там приоритет повышается «особым» образом. Идея в том, что потоку, который долго ждал, даётся шанс быстрее отработать «по свежим следам» события.

% \item Повышение приоритета потоков первого плана после ожидания (улучшение отзывчивости интерактивных приложений).  
% %Если поток в «активном» (foreground) процессе завершает ожидание объекта ядра, функция \texttt{KiUnwaitThread} может повысить его приоритет на величину \texttt{PsPrioritySeparation}. Это механизм, позволяющий приложениям с GUI реагировать быстрее после пробуждения. Заметим, что такое повышение приоритета (связанное с \texttt{PsPrioritySeparation}) поддерживается во всех версиях Windows и не отключается даже вызовом \texttt{SetThreadPriorityBoost}.

% \item Повышение приоритета после пробуждения GUI-потока (потоки-владельцы окон получают при пробуждении дополнительное повышение приоритета на 2).  
% Это делается с той же целью — повысить скорость реакции пользовательского интерфейса.

% \item Повышения приоритета, связанные с перезагруженностью центрального процессора (CPU Starvation).
% Раз в секунду специальный «диспетчер настройки баланса» (balance set manager) сканирует очереди готовых потоков и ищет те, которые в течение нескольких секунд (около 4) не получали процессор. Их приоритет временно поднимается (обычно до 15).

% %, чтобы они «пробились» к CPU и завершили свою работу. По окончании кванта приоритет снижается обратно. Если потоку всё ещё не хватает процессорного времени, он возвращается в очередь готовых потоков, и через 4 секунды алгоритм может повториться. Чтобы оптимизировать расход CPU, диспетчер настройки баланса сканирует за один раз лишь 16 потоков и повышает приоритет не более чем у 10 из них.

% \item Другие псевдоповышающие механизмы, проявляющие себя при проигрывании мультимедиа. В отличие от других повышений приоритета, эти механизмы применяются непосредственно в режиме ядра. Повышение приоритета проигрывания мультимедиа управляются службой планировщика класса мультимедиа MMCSS (это не является настоящим повышением, служба просто устанавливает по необходимости новые базовые приоритеты для потоков).
% \end{itemize}

\begin{table}[h!]
	\caption{Рекомендуемые значения повышения приоритета.}
	\begin{center}
		\begin{tabular}{|p{100mm}|l|}
			\hline
			{Устройство} & {Приращение} \\
			\hline
			Жесткий диск, привод компакт-дисков, параллельный порт, видеоустройство & 1 \\
			\hline
			Сеть, почтовый слот, именованный канал, последовательный порт & 2 \\
			\hline
			Клавиатура, мышь & 6 \\
			\hline
			Звуковое устройство & 8 \\
			\hline
		\end{tabular}
	\end{center}
	\label{tab:io}
\end{table}

Рассмотрим последние 2 сценария подробнее. 

% \textbf{Перезагруженность центрального процессора}
% \subsection*{Перезагруженность центрального процессора}

% В Windows включен общий механизм ослабления загруженности центрального процессора, который называется диспетчером настройки баланса и является частью системного потока.

% Один раз в секунду этот поток сканирует очередь готовых потоков в поиске тех из них, которые находятся в состоянии ожидания около 4 секунд.
% Если такой поток будет найден, диспетчер настройки баланса повышает его приоритет до 15 единиц и устанавливает квантовую цель эквивалентной тактовой частоте процессора при подсчете 3 квантовых единиц.
% Как только квант истекает, приоритет потока тут же снижается до обычного базового приоритета.
% Если поток не был завершен и есть готовый к запуску поток с более высоким уровнем приоритета, поток с пониженным приоритетом возвращается в очередь готовых потоков.

% Для минимизации времени своей работы, диспетчер настройки баланса сканирует только 16 готовых потоков.
% Если на данном уровне приоритета имеется больше потоков, он запоминает то место, на котором остановился, и начинает с него при следующем проходе очереди.
% Кроме того, он за один проход повысит приоритет только 10 потоков.
% Если найдет 10 потоков, заслуживающих именно этого повышения, он прекратит сканирование на этом месте и начнет его с этого же места при следующем проходе.

% \textbf{MMCSS}
\subsection*{MMCSS}

MMCSS работает с вполне определенными задачами, включая следующие: аудио, захват, распределение, игры, проигрывание, аудио профессионального качества, задачи администратора многооконного режима.

Каждая из этих задач включает информацию о свойствах, отличающих их друг от друга.
Одно из наиболее важных свойств для планирования потоков называется категорией планирования --- Scheduling Category, которое является первичным фактором, определяющим приоритет потоков, зарегистрированных с MMCSS.
На рисунке \ref{img:6} показаны различные категории планирования.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{img/6 (2).png}
    \caption{Категории планирования}
	\label{img:6}
\end{figure}

Механизм, положенный в основу MMCSS, повышает приоритет потоков внутри зарегистрированного процесса до уровня, соответствующего их категории планирования и относительного приоритета внутри этой категории на гарантированный срок.
Затем он снижает категорию этих потоков до Exhausted, чтобы другие, не относящиеся к мультимедийным приложениям потоки, также могли получить ресурс.

\subsection*{IRQL}

Для обеспечения поддержки мультизадачности системы, когда исполняется код режима ядра, Windows использует приоритеты прерываний IRQL --  Interrupt Request Level.

Прерывания обслуживаются в порядке их приоритета. При возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. Последний повышает IRQL и вызывает
процедуру обслуживания прерывания ISR -- Interrupt Service Routine.

После выполнения ISR диспетчер прерывания понижает IRQL процессора до исходного уровня загружает сохраненные ранее данные о состоянии машины. Прерванный поток возобновляется с той точки, где он был прерван. Когда ядро понижает IRQL, могут начать обрабатываться ранее замаскированные прерывания с более низким приоритетом. Тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.

В ядре IRQL-уровни представлены в виде номеров от 0 до 31, где более высоким номерам соответствуют прерывания с более высоким приоритетом.

На рисунке \ref{img:7} показаны уровни IRQL. \clearpage
\begin{figure}[h]
	\centering
	\includegraphics[width=0.9\textwidth]{img/image.png}
    \caption{Категории планирования}
	\label{img:7}
\end{figure}






\subsection{UNIX}

В современных системах UNIX ядро является вытесняющим --- процесс в режиме ядра может быть вытеснен более приоритетным процессом, также находящимся в режиме ядра.
Это сделано для того, чтобы система могла обслуживать процессы реального времени, такие как  аудио и видео.

Согласно приоритетам процессов и принципу вытесняющего циклического планирования формируется очередь готовых к выполнению процессов.
В первую очередь выполняются процессы с большим приоритетом.
Процессы с одинаковыми приоритетами выполняются в течение кванта времени, циклически друг за другом.

Приоритет задается любым целым числом, лежащим в диапазоне от 0 до 127 (чем меньше число, тем выше приоритет).
Приоритеты от 0 до 49 зарезервированы для ядра, они являются фиксированными величинами.
Прикладные процессы могут обладать приоритетом в диапазоне 50~--~127.

В традиционных системах UNIX приоритет процесса определяется двумя факторами: 
\begin{itemize}
	\item фактор <<любезности>> – целое число в диапазоне от 0 до 39 со значением 20 по умолчанию. Чем меньше значение фактора любезности, тем выше приоритет процесса. Пользователи могут повлиять на приоритет процесса при помощи изменения этого фактора, используя системный вызов nice (но только суперпользователь имеет полномочия увеличивать приоритет процесса);
	\item фактор утилизации --- степень загруженности CPU в момент последнего обслуживания им процесса. Этот фактор позволяет системе динамически изменять приоритет процесса.
\end{itemize}

Планировщик использует p\_pri для принятия решения о том, какой процесс направить на выполнение.
У процесса, находящегося в режиме задачи, значения p\_pri и p\_usrpri идентичны.
Значение текущего приоритета p\_pri может быть повышено планировщиком для выполнения процесса в режиме ядра.
Когда процесс просыпается после блокировки в системном вызове, его приоритет временно повышается.
При создании процесса поле p\_cpu инициализируется нулем.
На каждом тике обработчик таймера увеличивает поле p\_cpu текущего процесса на единицу, до максимального значения, равного 127.

% NOTE: хз, откуда, но в интернете есть по запросу "приоритеты ядра"
% \newpage
\begin{table}[h]
    \caption{Таблица приоритетов в системе 4.3BSD UNIX}
	\label{tab:bsd}
	\begin{center}
		\begin{tabular}{ |c|c|c|  }
			\hline
			{Приоритет} & {Значение} & {Описание} \\
			\hline
			{PSWP} & 0 & Свопинг \\
			\hline
			{PSWP + 1} & 1 & Страничный демон \\
			\hline
			{PSWP + 1/2/4} & 1/2/4 & Другие действия по обработке памяти \\
			\hline
			{PINOD} & 10 & Ожидание освобождения inode \\
			\hline
			{PRIBIO} & 20 & Ожидание дискового ввода-вывода \\
			\hline
			{PRIBIO + 1} & 21 & Ожидание освобождения буфера \\
			\hline
			{PZERO} & 25 & Базовый приоритет \\
			\hline
			{TTIPRI} & 28 & Ожидание ввода с терминала \\
			\hline
			{TTOPRI} & 29 & Ожидание вывода с терминала \\
			\hline 
			{PWAIT} & 30 & Ожидание завершения процесса потомка \\
			\hline
			{PLOCK} & 35 & Консультативное ожидание блокир. ресурса \\
			\hline
			{PSLEP} & 40 & Ожидание сигнала \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\begin{table}[h]
    \caption{Системные приоритеты сна в системах 4.3BSD UNIX и SCO UNIX}
	\begin{center}
		\begin{tabular}{|l|p{75pt}|p{75pt}|} 
			\hline
			{Событие} & {Приоритет 4.3BSD UNIX} & {Приоритет SCO UNIX}\\
			\hline
			{Ожидание загрузки страницы/сегмента} & 0 & 95\\
			\hline
			{Ожидание индексного дескриптора} & 10 & 88\\
			\hline
			{Ожидание ввода/вывода} & 20 & 81 \\
			\hline
			{Ожидание буфера} & 30 & 80\\
			\hline
			{Ожидание терминального ввода} &    & 75\\
			\hline
			{Ожидание терминального вывода} &    & 74\\
			\hline
			{Ожидание завершения выполнения} &    & 73\\
			\hline
			{Ожидание события} & 40 & 66\\
			\hline
		\end{tabular}
	\end{center}
	\label{tbl:sleeppriority}
\end{table}

Каждую секунду обработчик прерывания таймера инициализирует отложенный вызов процедуры schedcpu(), которая уменьшает значение p{\_}cpu каждого процесса исходя из фактора <<полураспада>> (decay factor).
В {\ttfamily 4.3BSD} для расчета полураспада применяется следующая формула:
\[
d = \frac{2\cdot load{\_}average}{2\cdot load{\_}average + 1},
\]
где load{\_}average --- это среднее количество процессов в состоянии готовности к выполнению, за последнюю секунду.
Процедура schedcpu() также пересчитывает приоритеты режима задачи всех процессов по формуле
\[
{p\_usrpri} = PUSER + \frac{p{\_}cpu}{4} + 2\cdot {p{\_}nice},
\]
где {\ttfamily PUSER} --- базовый приоритет в режиме задачи, равный 50.

Таким образом, если процесс до вытеснения другим процессом использовал большое количество процессорного времени, его p{\_}cpu будет увеличен, что приведет к увеличению значения p{\_}usrpri и, следовательно, к понижению приоритета.
Чем дольше процесс простаивает в очереди на выполнение, тем меньше его p{\_}cpu, и, соответственно, выше приоритет. 

Такая схема позволяет исключить бесконечное откладывание низкоприоритетных процессов.
При ее применении процессы, которые осуществляют много операций ввода-вывода, получают преимущество, так как они проводят много времени в ожидании завершения этих операций.
Напротив, те процессы, что производят много вычислений, используют большое количество процессорного времени, и их приоритет после вытеснения будет понижен. 

\subsubsection*{Потоки UNIX}

Некоторым приложениям требуется выполнять несколько крупных независимых задач, используя одно и то же адресное пространство и другие ресурсы. Традиционные системы UNIX либо вынуждают выполнять задачи последовательно, либо использовать неуклюжие и малоэффективные механизмы параллелизма. Традиционная модель не позволяет в полной мере задействовать возможности многопроцессорных систем, поскольку процесс одновременно может использовать только один процессор. Приложению приходится создавать несколько процессов и искать способы совместного использования памяти и ресурсов, а также синхронизации.

Современные системы UNIX предлагают решение приведенных проблем при помощи различных технологий нитей, реализованных в ОС с целью поддержки параллельного выполнения заданий. В каждом варианте UNIX для их обозначения применяются свои термины, например нити ядра, прикладные нити, прикладные нити, поддерживаемые ядром, C-threads, pthreads и «легковесные» процессы (lightweight processes).



\newpage

\subsection*{\center{ВЫВОДЫ}}

% Семейство ОС Windows и семейство OC UNIX оба являются системами разделения времени с динамическими приоритетами и вытеснением.
% В связи с общим подходом обработчик прерывания от системного таймера выполняет в этих системах схожие функции: 

% \begin{itemize}
% 	\item инициализурует отложенные вызовы функций, относящихся к работе планировщика (например, пересчет динамических приоритетов);
% 	\item декрементирует счетчики времени: часов, таймеров, будильников реального времени, а также счетчики времени отложенных действий;
% 	\item выполняет декремент кванта.
% \end{itemize}

% Так как обработчик прерывания таймера выполняется на высочайшем уровне привилегий, и никакая другая работа в системе не может выполняться, пока он не завершится, его работа устроена так, чтобы он выполнялся как можно быстрее. 

% Для того чтобы исключить бесконечное откладывание пользовательских процессов, повысить уровень отзывчивости системы и поддерживать процессы реального времени, такие как аудио и видео, в семействах ОС Windows и UNIX выполняется пересчет их динамических приоритетов, однако реализация пересчета в этих семействах отличается. 

Операционные системы семейств Windows и UNIX являются системами разделения времени с динамическими приоритетами и вытеснением, поэтому обработчик прерывания от системного таймера выполняет в этих системах схожие функции: 
\begin{itemize}
    \item декремент кванта потока в UNIX и процесса Windows;
	\item инициализация отложенных задач, относящихся к работе планировщика (например, пересчет динамических приоритетов);
	\item инкремент счетчиков времени и декремент счетчиков таймеров, будильников реального времени, счетчиков времени отложенных задач.
	
\end{itemize}

Пересчет динамических приоритетов осуществляется только для пользовательских процессов, чтобы избежать бесконечного откладывания.

В UNIX приоритет пользовательского процесса (процесса в режиме задач) может динамически пересчитываться. Пользователь может только понижать приоритет, при этом значение поля nice увеличивается. Для повышения приоритета нужны права superuser. Приоритеты ядра -- фиксированные величины.

В Windows при создании процесса ему назначается базовый приоритет, относительно базового приоритета процесса потоку назначается относительный приоритет.

\newpage

% \renewcommand\refname{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% \phantomsection\begingroup
% \bibliographystyle{modified-utf8gost705u}
% \raggedright
% \bibliography{bibliography}
% \addcontentsline{toc}{section}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
% \endgroup

\end{document}