# ЗАЧЕМ ВЫ ПРИШЛИ СЮДА УЧИТЬСЯ?????????

=== Русский Язык. Вопросы: ===

1) Почему у демона нет терминальной группы?

Ответ: потому что нет управляющего терминала, а значит и терминальной группы

3) Сколько в программе потоков? Какие?

Ответ: два: основной и дополнительный

4) Точка в программе, где демон становится многопоточным?

Ответ: вызов pthread_create

5) Зачем создаем второй поток?

Ответ: чтобы перехватывать сигналы главного

6) Какие сигналы перехватывает поток?

Ответ: SIGHUB и SIGTERM (кста в этом месте, если у вас стоит не switch-case или switch-case без default, то пошлет писать как в Стивенсоне)

7) Вот вы после создания демона вызываете функцию already_running - зачем?

Ответ: чтобы обеспечить работу демона в единственном экземпляре

8) А конкретнее?

Ответ: функция сообщает, что демон уже запущен

9) Какой прием используется для обеспечения единственности экземпляра?

Ответ: Файл блокировки (lockfile)

10) Поясните за already_running

Ответ: при первом заходе создается файл, при последующих открывается. далее блокируем файл

11) Построчно объясните как работает lockfile

Ответ: мы инициализируем экземпляр структуры flock и заполняем поля (кста на другие формулировки она агрится). в type ставим flag_writelock...

12) Что определяют ТРИ поля структуры флок?

Ответ: блокировку на весь файл

13) Что с этим делаем?

Ответ: передаем в вызов fcntl

14) Что делает fcntl?

Ответ: file control - управление файлами. задает разрешения/режимы работы с файлами

15) Прокомментируйте main. Каким образом что тут делаете?

Ответ: инициализируем структуру sigaction, которая описывает поведения при обработки сигналов. Устанавливаем реакцию на реакцию по умолчанию

16) Что значит по умолчанию?

Ответ: способом, установленным системой

17) Зачем делаете sigemptyset?

Ответ: сбрасывается маска множества/сета сигналов, которые будут заблокированы (sa_mask).

18) Дальше...

Ответ: зануляем специальное поведение (sa_flags/моя формулировка очень стремная)

19) в sigaction что делаем?

Ответ: определяем поведение для sighup

20) Дальше...

Ответ: sigfillset - заполняем маску сигналов, которые будут блокироваться. А затем уже определяем поведение для потока.

21) Для какого потока?

Ответ: для дополнительного

22) Что значит SIG_BLOCK?

Ответ: это union текущей маски + заполненной маски

23) Ну а в целом, зачем такие преобразования с масками были нужны?

Ответ (неуверен): Мы сбросили маску. Сброшенную маску передали в sigfillset. Дальше шла какая-то фраза про "Нет ограничений на прерыв сигналов...". Установили SIGHUP по умолчанию.

24) То есть что мы сделали?

Ответ: сначала объявили такое поведение, а затем вызвали поток. название pthread_sigmask говорит о том, что мы это делаем для потока, вызванного функцией pthread_create

25) Почему демон должен существовать в единственном экземпляре?

Ответ: Каждый экземпляр одного демона делает одно и тоже, что и другой экземпляр того же демона

26) Нет, вы вообще видели системные демоны? Там, kthreadd, flush... Почему они в единственном экземпляре?

Ответ: Системные демоны выполняют важные системные функции. В системе решено, какой конкретный экземпляр должен что делать. Система должна определять, какой демон был вызван в какой конкретный момент. Несколько экземпляров одного и того же демона будут работать с одними и теми же ресурсами. Тогда мы вынуждены писать для них взаимоисключение. Как говорится нахуя, если можно реально сделать на каждый цпу по одному демону на каждый ресурс.

27) У вас код не работает! У вас слово return написано через i! Где r?

Ответ: (приближаете код) Вот, смотрите: ар, и, ти, ю, АРРРР, эн. (её ответ - шрифт плохой в vscode)
